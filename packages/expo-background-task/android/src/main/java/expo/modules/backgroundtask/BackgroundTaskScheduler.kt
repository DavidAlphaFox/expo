package expo.modules.backgroundtask

import android.content.Context
import android.os.Build
import android.util.Log
import androidx.work.Constraints
import androidx.work.Data
import androidx.work.ExistingPeriodicWorkPolicy
import androidx.work.NetworkType
import androidx.work.Operation
import androidx.work.PeriodicWorkRequestBuilder
import androidx.work.WorkInfo
import androidx.work.WorkManager
import com.facebook.react.common.build.ReactBuildConfig
import com.google.common.util.concurrent.ListenableFuture
import expo.modules.interfaces.taskManager.TaskServiceProviderHelper
import kotlinx.coroutines.CompletableDeferred
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.suspendCancellableCoroutine
import java.time.Duration
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

class BackgroundTaskScheduler {
  companion object {
    // Shared executor
    val sharedExecutor = Executors.newCachedThreadPool()
    // Unique identifier (generated by us) to identify the worker
    private const val WORKER_IDENTIFIER = "EXPO_BACKGROUND_WORKER"

    // Log tag
    private val TAG: String = BackgroundTaskScheduler::class.java.simpleName

    /**
     * Schedules the worker task to run. The worker should run periodically.
     */
    suspend fun startWorker(context: Context, appScopeKey: String, intervalMinutes: Long): Boolean {
      // Ensure we have the react context
      Log.i(TAG, "Enqueuing worker with identifier $WORKER_IDENTIFIER")

      val data = Data.Builder()
        .putString("appScopeKey", appScopeKey)
        .build()
      val constraints = Constraints.Builder()
        .setRequiresBatteryNotLow(true)
        .setRequiredNetworkType(NetworkType.CONNECTED)
        .build()

      // Create the work request
      val builder = PeriodicWorkRequestBuilder<BackgroundTaskWork>(
        repeatIntervalTimeUnit = TimeUnit.MINUTES,
        repeatInterval = intervalMinutes
      )
        .setInputData(data)
        .setConstraints(constraints)

      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        // Add minimum interval here as well so that the work doesn't start immediately
        // In Debug builds we wait 30 seconds to make sure background tasks are easy to test.
        // Remember to put the app in the background for the task to run.
        if (ReactBuildConfig.DEBUG) {
          builder.setInitialDelay(Duration.ofSeconds(30))
        } else {
          builder.setInitialDelay(Duration.ofMinutes(intervalMinutes))
        }
      }

      // Create work request
      val workRequest = builder.build()

      // Get Work manager
      val workManager = WorkManager.getInstance(context)

      // Enqueue the work
      return try {
        val operation = workManager.enqueueUniquePeriodicWork(
          WORKER_IDENTIFIER,
          ExistingPeriodicWorkPolicy.CANCEL_AND_REENQUEUE,
          workRequest
        ).await()

        Log.i(TAG, "Worker enqueued successfully")
        true
      } catch (e: Exception) {
        Log.e(TAG, "Worker failed to start with error " + e.message)
        false
      }
    }

    /**
     * Cancels the worker task
     */
    suspend fun stopWorker(context: Context): Boolean {
      Log.i(TAG, "Cancelling worker with identifier $WORKER_IDENTIFIER")

      // Stop our main worker
      val workManager = WorkManager.getInstance(context)
      return try {
        workManager.cancelUniqueWork(WORKER_IDENTIFIER).await()
        workManager.pruneWork().await()
      } catch (e: Exception) {
        Log.i(TAG, "Stopping worker failed with error " + e.message)
        false
      }
    }

    /**
     * Returns true if the worker task is pending
     */
    suspend fun isWorkerRunning(context: Context): Boolean {
      val workInfo = getWorkerInfo(context)
      return workInfo?.state == WorkInfo.State.RUNNING ||
        workInfo?.state == WorkInfo.State.ENQUEUED
    }

    /**
     * Runs tasks with the given appScopeKey
     */
    suspend fun runTasks(context: Context, appScopeKey: String) {
      // Get task service
      val taskService = TaskServiceProviderHelper.getTaskServiceImpl(context)
        ?: throw MissingTaskServiceException()

      Log.i(TAG, "runTasks: $appScopeKey")

      // Get all task consumers
      val consumers = taskService.getTaskConsumers(appScopeKey)
      Log.i(TAG, "runTasks: number of consumers ${consumers.size}")

      val tasks = consumers.mapNotNull { consumer ->
        val bgTaskConsumer = consumer as? BackgroundTaskConsumer ?: return@mapNotNull null

        Log.i(TAG, "runTasks: executing tasks for consumer of type ${consumer.taskType()}")

        val taskCompletion = CompletableDeferred<Unit>()

        bgTaskConsumer.executeTask {
          Log.i(TAG, "Task successfully finished")
          taskCompletion.complete(Unit)
        }

        taskCompletion
      }

      // Await all tasks to complete
      tasks.awaitAll()
    }

    /**
     * Returns the worker info object from the WorkManager if the worker has been
     * registered, otherwise returns null
     */
    private suspend fun getWorkerInfo(context: Context): WorkInfo? {
      // Get work manager
      val workManager = WorkManager.getInstance(context)

      return try {
        val workInfos = workManager.getWorkInfosForUniqueWork(WORKER_IDENTIFIER).await()
        return workInfos.firstOrNull()
      } catch (e: Exception) {
        Log.i(TAG, "Calling getWorkInfosForUniqueWork failed with error " + e.message)
        null
      }
    }

    /**
     * Helper function for calling functions returning an Operation
     */
    suspend fun Operation.await(): Boolean = suspendCancellableCoroutine { continuation ->
      val future = this.result

      future.addListener({
        try {
          future.run { get() }
          continuation.resume(true)
        } catch (e: Exception) {
          continuation.resumeWithException(e)
        } finally {
          sharedExecutor.shutdown()
        }
      }, sharedExecutor)

      continuation.invokeOnCancellation {
        future.cancel(true)
        sharedExecutor.shutdown()
      }
    }

    /**
     * Helper function for calling functions returning a ListenableFuture
     */
    suspend fun <T> ListenableFuture<T>.await(): T = suspendCancellableCoroutine { continuation ->
      val executor = Executors.newCachedThreadPool()

      this.addListener({
        try {
          val result = runCatching { this.get() }
          continuation.resume(result.getOrThrow())
        } catch (e: Exception) {
          continuation.resumeWithException(e)
        } finally {
          executor.shutdown()
        }
      }, executor)

      continuation.invokeOnCancellation {
        this.cancel(true)
        executor.shutdown()
      }
    }
  }
}
